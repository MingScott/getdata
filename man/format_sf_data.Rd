% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/format_sf_data.R
\name{format_sf_data}
\alias{format_sf_data}
\alias{relocate_sf_col}
\alias{rename_sf_col}
\alias{bind_boundary_col}
\alias{bind_units_col}
\title{Format simple feature data}
\usage{
format_sf_data(
  x,
  crs = getOption("getdata.crs", default = 3857),
  erase_data = NULL,
  dTolerance = NULL,
  smooth = FALSE,
  sf_col = NULL,
  sf_req = TRUE,
  ...
)

relocate_sf_col(x, .after = dplyr::everything(), ...)

rename_sf_col(x, sf_col = "geometry")

bind_boundary_col(x, boundary = NULL, join = NULL, col = "name", ...)

bind_units_col(
  x,
  y,
  units = NULL,
  drop = FALSE,
  keep_all = TRUE,
  .id = NULL,
  ...
)
}
\arguments{
\item{x}{object of class \code{sfg}, \code{sfc} or \code{sf}}

\item{crs}{Coordinate reference system for returned data, Default: getOption("getdata.crs", default =
3857)}

\item{erase_data}{A \code{sf}, \code{sfc}, or \code{bbox} object with the geometry to erase
from data, Default: \code{NULL}}

\item{dTolerance}{numeric; tolerance parameter, specified for all or for each
feature geometry. If you run \code{st_simplify}, the input data is
specified with long-lat coordinates and \code{sf_use_s2()} returns
\code{TRUE}, then the value of \code{dTolerance} must be specified in
meters.}

\item{smooth}{If \code{TRUE}, smooth data with \link[smoothr:smooth]{smoothr::smooth} using default
method and parameters, Default: \code{FALSE}.}

\item{sf_col}{Name to use for the sf column after renaming; defaults to "geometry".}

\item{sf_req}{If \code{TRUE}, data must be a \code{sf} object. If \code{FALSE}, data is
passed to \link[overedge:as_sf]{overedge::as_sf} to convert data to an \code{sf} object.}

\item{...}{passed to \link{relocate_sf_col}}

\item{.after}{The location to place sf column after; defaults to
\link[dplyr:reexports]{dplyr::everything}.}

\item{boundary}{An sf object with a column named "name" or a list of sf
objects where all items in the list have a "name" column.}

\item{join}{geometry predicate function; defaults to \code{NULL}, set to
\link[sf:geos_binary_pred]{sf::st_intersects} if key_list contains only POLYGON or MULTIPOLYGON objects
or \link[sf:st_nearest_feature]{sf::st_nearest_feature} if key_list contains other types.}

\item{y}{Vector of numeric or units values to bind to x.}

\item{units}{Units to use for y (if numeric) or convert to (if y is units
class); defaults to \code{NULL}.}

\item{drop}{If \code{TRUE}, apply the \link[units:drop_units]{units::drop_units} function to the column
with units class values and return numeric values instead; defaults to
\code{FALSE}.}

\item{keep_all}{If \code{FALSE}, keep all columns. If \code{FALSE}, return only the
named .id column.}

\item{.id}{Name to use for vector of units provided to "y" parameter, when
"y" is bound to the "x" data frame or tibble as a new column.}

\item{data}{A \code{sf} object or, if \code{sf_req} is \code{FALSE}, any object that can be
converted to an \code{sf} object with \link[overedge:as_sf]{overedge::as_sf}.}

\item{erase}{If TRUE, pass \code{data} and \code{erase_data} to \link[overedge:st_erase]{overedge::st_erase},
Default: \code{FALSE}}
}
\value{
A \code{sf} object with columns and geometry modified based parameters.
}
\description{
The main \link{format_sf_data} function is a wrapper for the following common
steps in transforming an \code{sf} object and preparing for mapping or analysis:
}
\details{
\itemize{
\item Convert data to an \code{sf} object with \link[overedge:as_sf]{overedge::as_sf} if \code{sf_req} is \code{FALSE}
\item Make data valid with \link[sf:valid]{sf::st_make_valid} if needed
\item Format data with \link{format_data} using the ... parameters
\item Erase any data overlapping with \code{erase_data} (suggested for use with water or open space)
\item Simplify geometry with \link[sf:geos_unary]{sf::st_simplify} if \code{dTolerance} is provided
\item Smooth geometry with \link[smoothr:smooth]{smoothr::smooth} if \code{smooth} is \code{TRUE}
\item Rename the sf column to match \code{sf_col} (defaults to "geometry")
}

The helper functions for format_sf_data and additional formatting functions
for \code{sf} data are described in the details.

Helper functions for \link{format_sf_data}:
\itemize{
\item \link{rename_sf_col}: Rename \code{sf} column.
\item \link{relocate_sf_col}: Relocate \code{sf} column after selected columns (defaults to \code{\link[=everything]{everything()}}).
}

Additional formatting functions for \code{sf} objects:
\itemize{
\item \link{bind_boundary_col} uses \link[sf:st_join]{sf::st_join} to assign simple feature data to an
enclosing polygon. This function with other join functions to add columns
based on other spatial relationships, e.g. bind a column for the nearest
point feature.
}
}
\examples{
library(sf)

nc <- read_sf(system.file("shape/nc.shp", package = "sf"))
nc_county <- nc[2,]

# Transform coordinate reference system
st_crs(nc)$epsg
st_crs(format_sf_data(nc, crs = 3857))$epsg

# Simplify and smooth geometry
plot(nc_county, max.plot = 1)
nc_county_simple <- format_sf_data(nc_county, dTolerance = 5000, smooth = TRUE)
plot(nc_county_simple, max.plot = 1)

# Erase data
nc_co_water <- get_tigris_data(type = "area water", state = "NC", county = nc_county$NAME)
plot(format_sf_data(nc_county, erase_data = nc_co_water), max.plot = 1)

# Relocate sf column with a helper function function
relocate_sf_col(nc, .after = contains("AREA"))[,c(1, 2, 6)]

# If sf_req is set to FALSE, use any object that can be converted with sfext::as_sf
nc_bbox <- st_bbox(nc)
plot(format_sf_data(nc_bbox, erase_data = nc_county_simple, sf_req = FALSE))

# Bind area units (converting square meters to square miles)
bind_units_col(nc, st_area(nc), units = "mi^2")[,c(1,5,15)]

}
